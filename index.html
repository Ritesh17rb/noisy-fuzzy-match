<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hungarian Algorithm Entity Matcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .glass { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); }
        .transition-all { transition: all 0.3s ease; }
    </style>
</head>
<body class="p-6">

    <div class="max-w-6xl mx-auto">
        
        <!-- Header -->
        <div class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-slate-800">Noisy Entity Matcher</h1>
            <p class="text-slate-500 mt-2">Testing Global Optimization (Hungarian Algorithm) + Fuzzball</p>
        </div>

        <!-- Main Input Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            
            <!-- List A Input -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex flex-col h-96">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-semibold text-slate-700">List A (Source/Imported)</label>
                    <span class="text-xs text-slate-400 bg-slate-100 px-2 py-1 rounded">One item per line</span>
                </div>
                <textarea id="inputListA" class="flex-1 w-full p-3 bg-slate-50 border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none font-mono text-sm resize-none" spellcheck="false">John Smith
Batman
Dr. Hannibal
Unmatched Guy
States of America
Google Inc
Apple Computer</textarea>
            </div>

            <!-- List B Input -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex flex-col h-96">
                <div class="flex justify-between items-center mb-2">
                    <label class="font-semibold text-slate-700">List B (Target/Database)</label>
                    <span class="text-xs text-slate-400 bg-slate-100 px-2 py-1 rounded">One item per line</span>
                </div>
                <textarea id="inputListB" class="flex-1 w-full p-3 bg-slate-50 border border-slate-200 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent outline-none font-mono text-sm resize-none" spellcheck="false">Jon Smyth
Bruce Wayne
Hannibal Lecter
Joker
United States
Alphabet Corp
Apple Inc.</textarea>
            </div>
        </div>

        <!-- Controls & Manual Matches -->
        <div class="bg-blue-50 border border-blue-100 p-6 rounded-xl shadow-sm mb-8">
            <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-4">
                <div>
                    <h2 class="font-bold text-blue-900"><i class="fas fa-user-check mr-2"></i>Human-in-the-Loop Constraints</h2>
                    <p class="text-sm text-blue-700">Force specific matches. The algorithm will optimize around these locks.</p>
                </div>
                <button id="runBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow transition-all active:scale-95 flex items-center">
                    <i class="fas fa-play mr-2"></i> Run Matcher
                </button>
            </div>

            <!-- Manual Match Adder -->
            <div class="flex flex-col md:flex-row gap-2 mb-4">
                <select id="manualSelectA" class="flex-1 p-2 border border-blue-200 rounded bg-white text-sm"></select>
                <div class="text-blue-300 self-center"><i class="fas fa-arrow-right"></i></div>
                <select id="manualSelectB" class="flex-1 p-2 border border-blue-200 rounded bg-white text-sm"></select>
                <button id="addManualBtn" class="bg-white border border-blue-300 text-blue-700 hover:bg-blue-100 px-4 py-2 rounded font-medium text-sm">
                    Lock Pair
                </button>
            </div>

            <!-- Active Manual Matches Tags -->
            <div id="manualTags" class="flex flex-wrap gap-2 min-h-[40px]">
                <!-- Tags injected here -->
                <span class="text-sm text-gray-400 italic">No manual locks active.</span>
            </div>
        </div>

        <!-- Results Section -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Matches Table -->
            <div class="lg:col-span-2 bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden">
                <div class="p-4 bg-slate-50 border-b border-slate-200 flex justify-between items-center">
                    <h3 class="font-bold text-slate-700">Optimized Matches</h3>
                    <span id="matchCount" class="text-xs font-bold bg-green-100 text-green-700 px-2 py-1 rounded-full">0 Pairs</span>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-left border-collapse">
                        <thead>
                            <tr class="text-xs uppercase text-slate-500 bg-slate-50 border-b">
                                <th class="p-3">Source (List A)</th>
                                <th class="p-3">Target (List B)</th>
                                <th class="p-3 text-right">Similarity</th>
                                <th class="p-3 text-center">Type</th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody" class="text-sm">
                            <!-- Rows injected here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Unmatched Items -->
            <div class="flex flex-col gap-6">
                <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex-1">
                    <div class="p-3 bg-red-50 border-b border-red-100">
                        <h3 class="font-bold text-red-800 text-sm">Unmatched Source (Leftovers)</h3>
                    </div>
                    <ul id="unmatchedSourceList" class="p-3 space-y-2 text-sm text-slate-600">
                        <li class="text-gray-400 italic">None</li>
                    </ul>
                </div>

                <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex-1">
                    <div class="p-3 bg-orange-50 border-b border-orange-100">
                        <h3 class="font-bold text-orange-800 text-sm">Unmatched Target (Leftovers)</h3>
                    </div>
                    <ul id="unmatchedTargetList" class="p-3 space-y-2 text-sm text-slate-600">
                        <li class="text-gray-400 italic">None</li>
                    </ul>
                </div>
            </div>
        </div>

    </div>

    <!-- MAIN LOGIC MODULE -->
    <script type="module">
        import { linearSumAssignment } from "https://esm.sh/linear-sum-assignment";
        import * as fuzzball from "https://esm.sh/fuzzball";

        // State
        let listA = [];
        let listB = [];
        let manualMatches = []; // Array of [source, target]

        // --- THE ALGORITHM (Provided by User) ---
        function matchListsGlobal(listA, listB, manualMatches = []) {
            const fixedSourceSet = new Set(manualMatches.map(m => m[0]));
            const fixedTargetSet = new Set(manualMatches.map(m => m[1]));

            const openA = listA.filter(item => !fixedSourceSet.has(item));
            const openB = listB.filter(item => !fixedTargetSet.has(item));

            const costMatrix = openA.map(rowItem => 
                openB.map(colItem => {
                    return fuzzball.token_sort_ratio(rowItem, colItem);
                })
            );

            let algorithmicMatches = [];
            
            if (openA.length > 0 && openB.length > 0) {
                const result = linearSumAssignment(costMatrix, { maximize: true });
                
                algorithmicMatches = Array.from(result.rowAssignments)
                    .map((colIndex, rowIndex) => {
                        if (colIndex !== undefined && colIndex !== -1 && openB[colIndex]) {
                            return {
                                source: openA[rowIndex],
                                target: openB[colIndex],
                                score: costMatrix[rowIndex][colIndex],
                                isManual: false
                            };
                        }
                        return null;
                    })
                    .filter(Boolean);
            }

            const formattedManualMatches = manualMatches.map(m => ({
                source: m[0],
                target: m[1],
                score: 100,
                isManual: true
            }));

            const allMatches = [...formattedManualMatches, ...algorithmicMatches];

            const matchedASet = new Set(allMatches.map(m => m.source));
            const matchedBSet = new Set(allMatches.map(m => m.target));
            
            const unmatchedSource = listA.filter(a => !matchedASet.has(a));
            const unmatchedTarget = listB.filter(b => !matchedBSet.has(b));

            return {
                matches: allMatches.sort((a, b) => b.score - a.score),
                unmatchedSource,
                unmatchedTarget
            };
        }

        // --- UI LOGIC ---

        const dom = {
            inputA: document.getElementById('inputListA'),
            inputB: document.getElementById('inputListB'),
            runBtn: document.getElementById('runBtn'),
            resultsBody: document.getElementById('resultsBody'),
            unmatchedSourceList: document.getElementById('unmatchedSourceList'),
            unmatchedTargetList: document.getElementById('unmatchedTargetList'),
            manualSelectA: document.getElementById('manualSelectA'),
            manualSelectB: document.getElementById('manualSelectB'),
            addManualBtn: document.getElementById('addManualBtn'),
            manualTags: document.getElementById('manualTags'),
            matchCount: document.getElementById('matchCount')
        };

        function parseInputs() {
            listA = dom.inputA.value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
            listB = dom.inputB.value.split('\n').map(s => s.trim()).filter(s => s.length > 0);
        }

        function updateDropdowns() {
            // Only show items in dropdowns that aren't already locked
            // Actually, for simplicity, show all, but we handle logic on add
            parseInputs();
            
            const renderOptions = (list, element) => {
                const currentVal = element.value;
                element.innerHTML = '<option value="">-- Select --</option>';
                list.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = item;
                    opt.textContent = item;
                    element.appendChild(opt);
                });
                element.value = currentVal; // try to keep selection
            };

            renderOptions(listA, dom.manualSelectA);
            renderOptions(listB, dom.manualSelectB);
        }

        function renderManualTags() {
            dom.manualTags.innerHTML = '';
            if (manualMatches.length === 0) {
                dom.manualTags.innerHTML = '<span class="text-sm text-gray-400 italic">No manual locks active.</span>';
                return;
            }

            manualMatches.forEach((match, index) => {
                const tag = document.createElement('div');
                tag.className = 'flex items-center bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded border border-blue-200';
                tag.innerHTML = `
                    <span>${match[0]} = ${match[1]}</span>
                    <button data-index="${index}" class="ml-2 text-blue-600 hover:text-blue-900 focus:outline-none">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                // Add delete listener
                tag.querySelector('button').addEventListener('click', (e) => {
                    const idx = parseInt(e.currentTarget.dataset.index);
                    manualMatches.splice(idx, 1);
                    renderManualTags();
                    runMatching(); // Auto re-run on delete
                });
                dom.manualTags.appendChild(tag);
            });
        }

        function runMatching() {
            parseInputs();
            const result = matchListsGlobal(listA, listB, manualMatches);

            // Render Matches
            dom.resultsBody.innerHTML = '';
            dom.matchCount.textContent = `${result.matches.length} Pairs`;

            result.matches.forEach(match => {
                const row = document.createElement('tr');
                row.className = 'border-b border-slate-100 hover:bg-slate-50 transition-colors';
                
                // Color code score
                let scoreColor = 'text-green-600';
                if (match.score < 80) scoreColor = 'text-yellow-600';
                if (match.score < 50) scoreColor = 'text-red-500';
                if (match.isManual) scoreColor = 'text-blue-600';

                const typeBadge = match.isManual 
                    ? `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800"><i class="fas fa-lock mr-1"></i> Locked</span>`
                    : `<span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-800">Auto</span>`;

                row.innerHTML = `
                    <td class="p-3 font-medium text-slate-700">${match.source}</td>
                    <td class="p-3 text-slate-700">${match.target}</td>
                    <td class="p-3 text-right font-mono ${scoreColor} font-bold">${match.score}%</td>
                    <td class="p-3 text-center">${typeBadge}</td>
                `;
                dom.resultsBody.appendChild(row);
            });

            // Render Unmatched Source
            dom.unmatchedSourceList.innerHTML = '';
            if (result.unmatchedSource.length === 0) {
                dom.unmatchedSourceList.innerHTML = '<li class="text-gray-300 italic text-xs">All items matched</li>';
            } else {
                result.unmatchedSource.forEach(item => {
                    const li = document.createElement('li');
                    li.className = "bg-red-50 text-red-700 px-2 py-1 rounded border border-red-100 text-xs";
                    li.textContent = item;
                    dom.unmatchedSourceList.appendChild(li);
                });
            }

            // Render Unmatched Target
            dom.unmatchedTargetList.innerHTML = '';
            if (result.unmatchedTarget.length === 0) {
                dom.unmatchedTargetList.innerHTML = '<li class="text-gray-300 italic text-xs">All items matched</li>';
            } else {
                result.unmatchedTarget.forEach(item => {
                    const li = document.createElement('li');
                    li.className = "bg-orange-50 text-orange-800 px-2 py-1 rounded border border-orange-100 text-xs";
                    li.textContent = item;
                    dom.unmatchedTargetList.appendChild(li);
                });
            }
        }

        // --- Event Listeners ---

        dom.runBtn.addEventListener('click', runMatching);
        
        dom.inputA.addEventListener('input', updateDropdowns);
        dom.inputB.addEventListener('input', updateDropdowns);

        dom.addManualBtn.addEventListener('click', () => {
            const valA = dom.manualSelectA.value;
            const valB = dom.manualSelectB.value;

            if (!valA || !valB) {
                alert("Please select items from both lists to create a lock.");
                return;
            }

            // Avoid duplicates
            if (manualMatches.some(m => m[0] === valA || m[1] === valB)) {
                alert("One of these items is already locked in a manual match.");
                return;
            }

            manualMatches.push([valA, valB]);
            renderManualTags();
            dom.manualSelectA.value = "";
            dom.manualSelectB.value = "";
            runMatching(); // Auto re-run on add
        });

        // Init
        updateDropdowns();
        // Wait a moment for modules to load then run initial match
        setTimeout(runMatching, 500);

    </script>
</body>
</html>